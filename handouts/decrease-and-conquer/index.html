<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=windows-1252"
      http-equiv="Content-Type">
    <title>Decrease and Conquer Algorithms</title>
  </head>
  <body>
    <span style="font-weight: bold;">Decrease and Conquer</span><br>
    <br>
    <span style="font-weight: bold;">Overview</span><br>
    <br>
    The general idea is to <br>
    <br>
    <div style="margin-left: 40px;">1. Reduce the problem into a smaller
      instance of the same problem;<br>
      <br>
      2. solve the smaller instance;<br>
      <br>
      3. extend the solution of the smaller instance to obtain a
      solution to the original problem.<br>
    </div>
    <br>
    There are three major variations:<br>
    <br>
    <div style="margin-left: 40px;">1. Decrease by a constant.<br>
      <br>
      2. Decrease by a constant factor.<br>
      <br>
      3. Decrease by a variable size.<br>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;">Decrease by a Constant</span><br>
    <br>
    Typically the constant being decreased by is 1. <br>
    <br>
    Examples:<br>
    <br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Insertion
    Sort <br>
    <br>
    <div style="margin-left: 40px;">&nbsp; Calculating <big><span
          style="font-weight: bold; font-style: italic;">A<sup>n</sup></span></big><br>
      <br>
      <br>
    </div>
    <br>
    <span style="font-weight: bold;">Decrease by a Constant Factor</span><br>
    <br>
    The constant factor is typically 2 resulting in a problem size
    reduction of n/2.<br>
    <br>
    Examples:<br>
    <br>
    <div style="margin-left: 40px;">Binary Search <br>
      <br>
      Fake Coin Problem<br>
      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>
      Calculating <big><span style="font-weight: bold; font-style:
          italic;">A<sup>n</sup></span></big><br>
    </div>
    <br>
    <span style="font-weight: bold;">Decrease by a Variable Size</span><br>
    <br>
    Examples<br>
    <br>
    <div style="margin-left: 40px;">Euclid's algorithm for calculating
      the GCD:<br>
      <br>
      <div style="margin-left: 80px;"><span style="font-weight: bold;">gcd(m,n)
=
gcd(n,
m
%


          n)<br>
          <br>
          where<br>
          <br>
          gcd(m,0) = m<br>
        </span></div>
    </div>
    <br>
    <br>
    <span style="font-weight: bold;">Generating Permutations</span><br>
    <br>
    A <span style="font-style: italic;">Permutations</span> of <span
      style="font-style: italic;">n</span> distinct elements <span
      style="font-style: italic;">x1, x2, .... xn</span> is an ordering
    of the <span style="font-style: italic;">n</span> elements.<br>
    <br>
    Example: <br>
    <br>
    What are the permutations of the elements {A B C}? <br>
    <br>
    How many possible permutations are there for <i>n</i> elements?<br>
    <br>
    <span style="font-weight: bold;">Algorithms for Generating
      Permutations</span><br>
    <br>
    <span style="font-weight: bold;">Bottom-Up (minimal change)</span><br>
    <br>
    <div style="margin-left: 40px;">&lt;&lt; We will demonstrate this as
      a class. &gt;&gt;<br>
    </div>
    <br>
    <span style="font-weight: bold;">Johnson-Trotter</span><br>
    <br>
    An element is considered to be <span style="font-style: italic;">mobile</span>
    if the arrow points to a smaller number adjacent to it.<br>
    <br>
    <div style="margin-left: 40px;"><big><span style="font-weight: bold;
          font-family: monospace;">initialize the permutation list</span></big><br>
    </div>
    <br>
    <div style="margin-left: 40px; font-family: monospace;"><big><span
          style="font-weight: bold;">while (the last permutation has a
          mobile element)</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">{</span><br style="font-weight:
          bold;">
        <span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; find its
          largest mobile element k</span><br style="font-weight: bold;">
        <br style="font-weight: bold;">
        <span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; swap k and
          the adjacent integer k's arrow points to</span><br
          style="font-weight: bold;">
        <br style="font-weight: bold;">
        <span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; reverse the
          direction of all the elements that are larger than k</span><br
          style="font-weight: bold;">
        <br style="font-weight: bold;">
        <span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; add the
          permutation to the list</span><br style="font-weight: bold;">
        <span style="font-weight: bold;">}</span><br style="font-weight:
          bold;">
      </big></div>
    <br>
    <div style="margin-left: 40px;">&lt;&lt; We will demonstrate this as
      a class. &gt;&gt;<br>
    </div>
    <br>
    <img
 style="width: 710px; height: 109px;" alt="" src="./JTexample.png">
    <br>
    Notice that the ordering of permutations is not natural. <span
      style="font-weight: bold;">Lexigraphic</span> order refers to the
    natural ordering of elements. In this case increasing:<br>
    <br>
    <div style="margin-left: 40px;">123, 132, 213, 231, 312, 321<br>
    </div>
    <br>
    <span style="font-weight: bold;">Generating Subsets</span><br>
    <br>
    <span style="font-weight: bold;">Decrease by One Algorithm</span><br>
    <br>
    <table style="text-align: left; width: 40%;" border="1"
      cellpadding="2" cellspacing="2">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><span style="font-weight:
              bold;">n</span><br>
          </td>
          <td style="vertical-align: top; text-align: center;"><span
              style="font-weight: bold;">subsets</span><br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">0<br>
          </td>
          <td style="vertical-align: top;">null<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">1<br>
          </td>
          <td style="vertical-align: top;">null, {a1}<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">2<br>
          </td>
          <td style="vertical-align: top;">null, {a1}, {a2}, {a1, a2}<br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">3<br>
          </td>
          <td style="vertical-align: top;">null, {a1}, {a2}, {a1, a2},
            {a3}, {a1, a3}, {a2, a3}, {a1, a2, a3} <br>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">4<br>
          </td>
          <td style="vertical-align: top; text-align: center;">{ <span
              style="font-style: italic;">What would this look like</span>?
            }<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <b>Bit Strings</b><br>
    <br>
    How might we be able to use bit strings to generate all subsets of
    the elements a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... a<sub>n</sub>?<br>
    <br>
    - <a target="_blank" href="./BitStrings.html">Solution</a> (don't
    peek!)<br>
    <br>
    <span style="font-weight: bold;">Gray Codes</span><br>
    <br>
    &lt;&lt; We will cover this in class. &gt;&gt;<br>
    <br>
    <br>
    <br>
    <br>
  </body>
</html>
